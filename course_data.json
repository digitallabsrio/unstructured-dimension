{
  "course_name": "Operating Systems: Virtualization, Concurrency & Persistence - Learn Interactively",
  "course_overview": "When it comes to operating systems, there are three main concepts: virtualization, concurrency, and persistence. These concepts lay the foundation for understanding how an operating system works.\n\nIn this extensive course, you'll cover each of those in its entirety. You'll start by covering the basics of CPU virtualization and memory such as: CPU scheduling, process virtualization, and API virtualization. You will then move on to concurrency concepts where youâ€™ll focus heavily on locks, semaphores, and how to triage concurrency bugs like deadlocks.\n\nTowards the end, you'll get plenty of hands-on practice with persistence via I/O devices and file systems. By the time you're done, you'll have mastered everything there is to know about operating systems.",
  "course_folder": "operating systems virtualization concurrency persistence",
  "course_lessons": [
    "0-a dialogue on the course",
    "1-introduction to operating systems",
    "2-virtualizing the cpu",
    "3-virtualizing memory",
    "4-concurrency",
    "5-persistence",
    "6-design goals",
    "7-some history",
    "8-summary",
    "9-a dialogue on virtualization",
    "10-introduction to processes",
    "11-the abstraction a process",
    "12-process api",
    "13-process creation a little more detail",
    "14-processes states",
    "15-data structures",
    "16-summary",
    "17-simulator",
    "18-exercise",
    "19-quiz on processes",
    "20-introduction to process api",
    "21-the fork system call",
    "22-the wait system call",
    "23-finally the exec system call",
    "24-why motivating the api",
    "25-process control and users",
    "26-useful tools",
    "27-summary",
    "28-exercise",
    "29-quiz on process api",
    "30-introduction to direct execution",
    "31-basic technique limited direct execution",
    "32-problem 1 restricted operations",
    "33-problem 2 switching between processes",
    "34-worried about concurrency",
    "35-summary",
    "36-exercise",
    "37-quiz on direct execution",
    "38-introduction to cpu scheduling",
    "39-workload assumptions and scheduling metrics",
    "40-first in first out fifo",
    "41-shortest job first sjf",
    "42-shortest time to completion first stcf",
    "43-a new metric response time",
    "44-round robin",
    "45-incorporating i o",
    "46-summary",
    "47-simulator",
    "48-exercise",
    "49-quiz on cpu scheduling",
    "50-introduction to multi level feedback",
    "51-mlfq basic rules",
    "52-attempt 1 how to change priority",
    "53-attempt 2 the priority boost",
    "54-attempt 3 better accounting",
    "55-tuning mlfq and other issues",
    "56-summary",
    "57-simulator",
    "58-exercise",
    "59-quiz on multi level feedback",
    "60-introduction to lottery scheduling",
    "61-basic concept tickets represent your share",
    "62-ticket mechanisms",
    "63-implementation",
    "64-an example",
    "65-why not deterministic",
    "66-the linux completely fair scheduler cfs",
    "67-weighting niceness",
    "68-how is cfs efficient",
    "69-summary",
    "70-simulator",
    "71-exercise",
    "72-quiz on lottery scheduling",
    "73-introduction to multi cpu scheduling",
    "74-background multiprocessor architecture",
    "75-dont forget synchronization",
    "76-one final issue cache affinity",
    "77-single queue scheduling",
    "78-multi queue scheduling",
    "79-linux multiprocessor schedulers",
    "80-summary",
    "81-simulator",
    "82-exercise",
    "83-quiz on multi cpu scheduling",
    "84-summary dialogue on cpu virtualization",
    "85-a dialogue on memory virtualization",
    "86-early systems",
    "87-multiprogramming and time sharing",
    "88-the address space",
    "89-goals",
    "90-summary",
    "91-exercise",
    "92-quiz on address space",
    "93-introduction to memory api",
    "94-types of memory",
    "95-the malloc call",
    "96-the free call",
    "97-common errors",
    "98-underlying os support",
    "99-other calls",
    "100-summary",
    "101-exercise",
    "102-quiz on memory api",
    "103-introduction to address translation",
    "104-assumptions",
    "105-an example",
    "106-dynamic hardware based relocation",
    "107-hardware support a summary",
    "108-operating system issues",
    "109-summary",
    "110-simulator",
    "111-exercise",
    "112-quiz on address translation",
    "113-introduction to segmentation",
    "114-segmentation generalized base bounds",
    "115-which segment are we referring to",
    "116-what about the stack",
    "117-support for sharing",
    "118-fine grained vs coarse grained segmentation",
    "119-os support",
    "120-summary",
    "121-simulator",
    "122-exercise",
    "123-quiz on segmentation",
    "124-introduction to free space management",
    "125-assumptions",
    "126-low level mechanisms",
    "127-basic strategies",
    "128-other approaches",
    "129-summary",
    "130-simulator",
    "131-exercise",
    "132-quiz on free space management",
    "133-introduction to paging",
    "134-a simple example and overview",
    "135-where are page tables stored",
    "136-whats actually in the page table",
    "137-paging also too slow",
    "138-a memory trace",
    "139-summary",
    "140-simulator",
    "141-exercise",
    "142-quiz on introduction to paging",
    "143-introduction to translation lookaside buffers",
    "144-tlb basic algorithm",
    "145-example accessing an array",
    "146-who handles the tlb miss",
    "147-tlb contents whats in there",
    "148-tlb issue context switches",
    "149-issue replacement policy",
    "150-a real tlb entry",
    "151-summary",
    "152-exercise",
    "153-quiz on translation lookaside buffer",
    "154-introduction to advanced page tables",
    "155-simple solution bigger pages",
    "156-hybrid approach paging and segments",
    "157-multi level page tables",
    "158-inverted page tables",
    "159-swapping the page tables to disk",
    "160-summary",
    "161-simulator",
    "162-exercise",
    "163-quiz on advanced page tables",
    "164-introduction to swapping mechanisms",
    "165-swap space",
    "166-the present bit",
    "167-the page fault",
    "168-what if memory is full",
    "169-page fault control flow",
    "170-when replacements really occur",
    "171-summary",
    "172-instructions for exercise",
    "173-exercise",
    "174-quiz on swapping mechanisms",
    "175-introduction to swapping policies",
    "176-cache management",
    "177-the optimal replacement policy",
    "178-a simple policy fifo",
    "179-another simple policy random",
    "180-using history lru",
    "181-workload examples",
    "182-implementing historical algorithms",
    "183-approximating lru",
    "184-considering dirty pages",
    "185-other vm policies",
    "186-thrashing",
    "187-summary",
    "188-simulator",
    "189-exercise",
    "190-quiz on swapping policies",
    "191-introduction to complete vm systems",
    "192-vax vms virtual memory memory management hardware",
    "193-vax vms virtual memory a real address space",
    "194-vax vms virtual memory page replacement",
    "195-vax vms virtual memory other neat tricks",
    "196-the linux virtual memory system the linux address space",
    "197-the linux virtual memory system page table structure",
    "198-the linux virtual memory system large page support",
    "199-the linux virtual memory system the page cache",
    "200-the linux virtual memory system security and buffer overflows",
    "201-the linux virtual memory system other security problems",
    "202-summary",
    "203-quiz on complete vm systems",
    "204-summary dialogue on memory virtualization",
    "205-a dialogue on concurrency",
    "206-introduction to concurrency and threads",
    "207-why use threads",
    "208-an example thread creation",
    "209-why it gets worse shared data",
    "210-the heart of the problem uncontrolled scheduling",
    "211-the wish for atomicity",
    "212-one more problem waiting for another",
    "213-summary why in os class",
    "214-simulator",
    "215-exercise",
    "216-quiz on concurrency and threads",
    "217-introduction to thread api",
    "218-thread creation",
    "219-thread completion",
    "220-locks",
    "221-condition variables",
    "222-compiling and running",
    "223-summary",
    "224-simulator",
    "225-exercise",
    "226-quiz on thread api",
    "227-introduction to locks",
    "228-locks the basic idea",
    "229-pthread locks",
    "230-building a lock",
    "231-evaluating locks",
    "232-controlling interrupts",
    "233-a failed attempt just using loads stores",
    "234-building working spin locks with test and set",
    "235-evaluating spin locks",
    "236-compare and swap",
    "237-load linked and store conditional",
    "238-fetch and add",
    "239-too much spinning what now",
    "240-a simple approach just yield baby",
    "241-using queues sleeping instead of spinning",
    "242-different os different support",
    "243-two phase locks",
    "244-summary",
    "245-exercise",
    "246-quiz on locks",
    "247-introduction to locked data structures",
    "248-concurrent counters",
    "249-concurrent linked lists",
    "250-concurrent queues",
    "251-concurrent hash table",
    "252-summary",
    "253-exercise",
    "254-quiz on locked data structures",
    "255-introduction to conditional variables",
    "256-definition and routines",
    "257-the producer consumer bounded buffer problem",
    "258-better but still broken while not if",
    "259-the single buffer producer consumer solution",
    "260-covering conditions",
    "261-summary",
    "262-instructions for exercise",
    "263-exercise",
    "264-quiz on condition variables",
    "265-introduction to semaphore",
    "266-semaphores a definition",
    "267-binary semaphores locks",
    "268-semaphores for ordering",
    "269-the producer consumer bounded buffer problem",
    "270-extending the solution for multiple producers and consumers",
    "271-reader writer locks",
    "272-the dining philosophers",
    "273-thread throttling",
    "274-how to implement semaphores",
    "275-summary",
    "276-exercise",
    "277-quiz on semaphores",
    "278-introduction to concurrency bugs",
    "279-what types of bugs exist",
    "280-non deadlock bugs",
    "281-deadlock bugs",
    "282-prevention",
    "283-deadlock avoidance via scheduling",
    "284-detection and recovery",
    "285-summary",
    "286-instructions for exercise",
    "287-exercise",
    "288-quiz on concurrency bugs",
    "289-introduction to event based concurrency",
    "290-the basic idea an event loop",
    "291-an important api select or poll",
    "292-using select",
    "293-a problem blocking system calls",
    "294-a solution asynchronous i o",
    "295-another problem state management",
    "296-what is still difficult with events",
    "297-summary",
    "298-exercise",
    "299-quiz on event based concurrency",
    "300-summary dialogue on concurrency",
    "301-a dialogue on persistence",
    "302-introduction to i o devices",
    "303-system architecture",
    "304-a canonical device",
    "305-the canonical protocol",
    "306-lowering cpu overhead with interrupts",
    "307-more efficient data movement with dma",
    "308-methods of device interaction",
    "309-fitting into the os the device driver",
    "310-case study a simple ide disk driver",
    "311-historical notes",
    "312-summary",
    "313-quiz on i o devices",
    "314-introduction to hard disk drives",
    "315-the interface",
    "316-basic geometry",
    "317-a simple disk drive",
    "318-a disk drive with multiple tracks seek time",
    "319-more details about hard drives",
    "320-i o time doing the math",
    "321-disk scheduling",
    "322-some other scheduling issues",
    "323-summary",
    "324-simulator",
    "325-exercise",
    "326-quiz on hard disk drives",
    "327-introduction to raid",
    "328-interface and raid internals",
    "329-fault model",
    "330-how to evaluate a raid",
    "331-raid level 0 striping",
    "332-raid level 1 mirroring",
    "333-raid level 4 saving space with parity",
    "334-raid level 5 rotating parity",
    "335-raid comparison a summary",
    "336-other interesting raid issues",
    "337-summary",
    "338-simulator",
    "339-exercise",
    "340-quiz on redundant disk arrays raid",
    "341-introduction to files and directories",
    "342-files and directories",
    "343-the file system interface",
    "344-reading and writing files",
    "345-reading and writing but not sequentially",
    "346-shared file table entries fork and dup",
    "347-writing immediately with fsync",
    "348-renaming files",
    "349-getting information about files",
    "350-removing files",
    "351-making directories",
    "352-reading and deleting directories",
    "353-hard links",
    "354-symbolic links",
    "355-permission bits and access control lists",
    "356-making and mounting a file system",
    "357-summary",
    "358-exercise",
    "359-quiz on files and directories",
    "360-introduction to file system implementation",
    "361-the way to think",
    "362-overall organization",
    "363-file organization the inode",
    "364-directory organization",
    "365-free space management",
    "366-access paths reading and writing",
    "367-caching and buffering",
    "368-summary",
    "369-simulator",
    "370-exercise",
    "371-quiz on file system implementation",
    "372-introduction to fast file system",
    "373-the problem poor performance",
    "374-ffs disk awareness is the solution",
    "375-policies how to allocate files and directories",
    "376-measuring file locality",
    "377-the large file exception",
    "378-a few other things about ffs",
    "379-summary",
    "380-simulator",
    "381-exercise",
    "382-quiz on fast file system",
    "383-introduction to fsck and journaling",
    "384-a detailed example",
    "385-solution 1 the file system checker",
    "386-solution 2 journaling or write ahead logging",
    "387-metadata journaling",
    "388-solution 3 other approaches",
    "389-summary",
    "390-simulator",
    "391-exercise",
    "392-quiz on fsck and journaling",
    "393-introduction to log structured file system",
    "394-writing to disk sequentially",
    "395-writing sequentially and effectively",
    "396-how much to buffer",
    "397-problem finding inodes",
    "398-solution through indirection the inode map",
    "399-completing the solution the checkpoint region",
    "400-reading a file from disk a recap",
    "401-what about directories",
    "402-a new problem garbage collection",
    "403-determining block liveness",
    "404-a policy question which blocks to clean and when",
    "405-crash recovery and the log",
    "406-summary",
    "407-simulator",
    "408-exercise",
    "409-quiz on log structured file system",
    "410-introduction to flash based ssds",
    "411-storing a single bit",
    "412-from bits to banks planes",
    "413-basic flash operations",
    "414-flash performance and reliability",
    "415-from raw flash to flash based ssds",
    "416-ftl organization a bad approach",
    "417-a log structured ftl",
    "418-garbage collection",
    "419-mapping table size",
    "420-wear leveling",
    "421-ssd performance and cost",
    "422-summary",
    "423-simulator",
    "424-exercise",
    "425-quiz on flash based ssds",
    "426-introduction to data integrity and protection",
    "427-disk failure modes",
    "428-handling latent sector errors",
    "429-detecting corruption the checksum",
    "430-using checksums",
    "431-a new problem misdirected writes",
    "432-one last problem lost writes",
    "433-scrubbing",
    "434-overheads of checksumming",
    "435-summary",
    "436-simulator",
    "437-exercise",
    "438-quiz on data integrity and protection",
    "439-summary dialogue on persistence",
    "440-a dialogue on distribution",
    "441-introduction to distributed systems",
    "442-communication basics",
    "443-unreliable communication layers",
    "444-reliable communication layers",
    "445-communication abstractions",
    "446-remote procedure call rpc",
    "447-summary",
    "448-exercise",
    "449-quiz on distributed systems",
    "450-introduction to network file system nfs",
    "451-a basic distributed file system",
    "452-on to nfs",
    "453-key to fast crash recovery statelessness",
    "454-the nfsv2 protocol",
    "455-from protocol to distributed file system",
    "456-handling server failure with idempotent operations",
    "457-improving performance client side caching",
    "458-the cache consistency problem",
    "459-implications on server side write buffering",
    "460-summary",
    "461-instructions for exercise",
    "462-exercise",
    "463-quiz on network file system nfs",
    "464-introduction to andrew file system afs",
    "465-afs version 1",
    "466-problems with version 1",
    "467-afs version 2",
    "468-cache consistency",
    "469-crash recovery",
    "470-scale and performance of afsv2",
    "471-afs other improvements",
    "472-summary",
    "473-simulator",
    "474-exercise",
    "475-quiz on andrew file system afs",
    "476-summary dialogue on distribution"
  ],
  "repo_name": "unstructured-dimension"
}
